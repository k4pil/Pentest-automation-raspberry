import re
from datetime import datetime

import paramiko


def establishConnection(ssh_server, ssh_port, user, pasd, public_key_auth, pk_file_location):
    ssh_client = paramiko.client.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        if public_key_auth:
            ssh_client.connect(
                hostname=ssh_server,
                port=ssh_port,
                username=user,
                key_filename=pk_file_location
            )
        else:
            ssh_client.connect(hostname=ssh_server,
                            port=ssh_port,
                            username=user,
                            password=pasd
            )
    except paramiko.ssh_exception.AuthenticationException as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.NoValidConnectionsError as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.BadAuthenticationType as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.BadHostKeyException as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.ChannelException as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.PartialAuthentication as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.PasswordRequiredException as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.ProxyCommandFailure as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except paramiko.ssh_exception.SSHException as e:
        ssh_client.close()
        return f"SSH error: {e}", None
    except TimeoutError:
        ssh_client.close()
        return "Connection timeout.", None

    return None, ssh_client

def isCommandInstalled(base_cmd, ssh_client):
    full_command = f"which {base_cmd}"
    _stdin, stdout, _stderr = ssh_client.exec_command(full_command)
    result = re.match(stdout.read().decode('utf-8'), 'not\ found')
    return result

def runCommand(ssh_client, base_cmd, arguments, save_out, no_out):
    ret_string = ""
    try:
        if save_out:
            output_file_name = datetime.now().strftime(f"%d-%m-%Y_%H-%M-%S_{base_cmd}")
            makedir = f"mkdir -p $HOME/offloaded_scans/ && "
            out_redirect = f"| tee $HOME/offloaded_scans/{output_file_name}.txt"
            full_command = f"{makedir} {base_cmd} {arguments} {out_redirect}"
        else:
            full_command = f"{base_cmd} {arguments}"
        _stdin, stdout, _stderr = ssh_client.exec_command(full_command)
        output = stdout.read().decode('utf-8')
        if no_out == False:
            ret_string += output
        if save_out:
            ret_string += f"\n\nFile saved on remote machine under $HOME/offloaded_scans/ with name {output_file_name}.txt"
    except paramiko.AuthenticationException:
        ret_string += "Authentication failed. Please check your username and password."
    except paramiko.SSHException as e:
        ret_string += f"SSH error: {e}"
    finally:
        ssh_client.close()
    return ret_string

def run(post_list):
    server_ip = post_list["server_ip"]
    server_ssh_port = post_list["server_ssh_port"]
    username = post_list["username"]
    password = post_list["password"]

    public_key_auth = False
    ssh_public_key_location = ""

    if "use_ssh_key" in post_list:
        ssh_public_key_location = post_list["ssh_public_key_location"]
        public_key_auth = True

    base_command = post_list["base_command"]
    arguments = post_list["arguments"]

    save_output = False
    no_output = False

    if "save_output" in post_list:
        save_output = True

    if "no_output" in post_list:
        no_output = True

    error_msg, ssh_client = establishConnection(
        server_ip,
        server_ssh_port,
        username,
        password,
        public_key_auth,
        ssh_public_key_location
    )


    if ssh_client != None:
        check = isCommandInstalled(
            base_command,
            ssh_client
        )

        if check == None:
            return runCommand(
                ssh_client,
                base_command,
                arguments,
                save_output,
                no_output
            )
        else:
            return f"{base_command} has not been installed on the server"
    else:
        return error_msg
